% OCR draft from PDF pages 235-258 (book chapter 8).
\chapter{Implementing \texttt{smpl}}
\label{chap:implementing-smpl}

\section{Introduction}
\label{sec:smpl-impl-intro}

This chapter walks through the design and C implementation of the core
\texttt{smpl} subsystem. The goal is practical understanding: enough detail to
debug, validate, and extend the simulator.

The source files discussed are:
\begin{itemize}
\item \texttt{smpl.c} (core simulation subsystem, excluding random variates),
\item \texttt{rand.c} (random variate generation),
\item \texttt{smpl.h} (external declarations and user directives),
\item \texttt{stat.c} (normal and $t$ quantile support used by batch means).
\end{itemize}

The implementation intentionally favors simple arrays and indexes over C
structs/pointers to keep correspondence with non-C implementations.

\section{The Element Pool and Namespace}
\label{sec:smpl-impl-pool}

\texttt{smpl.c} uses one basic 5-field element type for nearly all dynamic
structures (event-list entries, queue entries, descriptor pieces). A single
global pool is reused in two phases:
\begin{enumerate}
\item initialization phase: contiguous blocks are carved out for descriptors;
\item execution phase: remaining elements are linked as a free list for
  schedule/queue activity.
\end{enumerate}

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\toprule
Category & Representative functions in \texttt{smpl.c} \\
\midrule
Initialization & \texttt{smpl}, \texttt{reset}, \texttt{set\_model}, \texttt{save\_name} \\
Descriptors & \texttt{facility}, \texttt{get\_blk}, \texttt{get\_elm}, \texttt{put\_elm} \\
Event scheduling & \texttt{schedule}, \texttt{cause}, \texttt{cancel}, \texttt{suspend}, \texttt{enlist} \\
Facility control & \texttt{request}, \texttt{preempt}, \texttt{release}, \texttt{inq}, \texttt{status} \\
Statistics & \texttt{U}, \texttt{B}, \texttt{Lq}, \texttt{report}, \texttt{reportf} \\
Debug/UI hooks & \texttt{trace}, \texttt{msg}, \texttt{dump}, \texttt{error}, \texttt{sendto} \\
\bottomrule
\end{tabular}
\caption{\texttt{smpl.c} Function Names}
\label{fig:smpl-func-list}
\end{figure}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[x=0.95cm,y=0.95cm,>=Latex]
  \draw[line width=1pt] (0,0) rectangle (12,1.2);
  \draw[line width=0.9pt] (3.8,0) -- (3.8,1.2);
  \draw[line width=0.9pt] (8.2,0) -- (8.2,1.2);
  \node at (1.9,0.6) {\small model/facility headers};
  \node at (6.0,0.6) {\small descriptor blocks};
  \node at (10.1,0.6) {\small free list};
  \draw[decorate,decoration={brace,amplitude=5pt}] (0,-0.25) -- (8.2,-0.25)
    node[midway,below=6pt]{\small initialization phase allocations};
  \draw[decorate,decoration={brace,amplitude=5pt}] (8.2,-0.25) -- (12,-0.25)
    node[midway,below=6pt]{\small execution-time dynamic elements};
\end{tikzpicture}
\caption{The \texttt{smpl} Element Pool}
\label{fig:smpl-element-pool}
\end{figure}

Namespace strings (model/facility names) are stored in a shared character
array; helper routines save and return pointers into this namespace.

\section{Initialization}
\label{sec:smpl-impl-init}

The subsystem initializes through \texttt{smpl(m,s)}:
\begin{itemize}
\item sets clocks and measurement interval start to zero,
\item initializes pool/namespace indexes,
\item stores model name,
\item selects random stream for the run,
\item initializes monitor hooks (if \texttt{mtr} is enabled).
\end{itemize}

\texttt{reset()} reinitializes measurement accumulators without rebuilding model
structures. It calls \texttt{resetf()} to clear facility/queue statistics and resets
the interval start time to current simulation time.

\section{Facility Definition}
\label{sec:smpl-impl-facility-def}

\texttt{facility(name,nservers)} allocates a descriptor of size $(n+2)$ elements:
a 2-element header plus one element per server.

Descriptors are obtained from contiguous pool blocks via \texttt{get\_blk()} and
linked into a facility chain used later by reset/report processing.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=Latex]
  \draw[line width=1pt] (0,0) rectangle (5.8,3.8);
  \draw[line width=0.8pt] (0,3.0) -- (5.8,3.0);
  \draw[line width=0.8pt] (0,2.2) -- (5.8,2.2);
  \draw[line width=0.8pt] (0,1.4) -- (5.8,1.4);
  \draw[line width=0.8pt] (3.0,0) -- (3.0,3.8);
  \node[font=\small] at (1.5,3.4) {name ptr};
  \node[font=\small] at (4.4,3.4) {queue head};
  \node[font=\small] at (1.5,2.6) {nservers};
  \node[font=\small] at (4.4,2.6) {busy count};
  \node[font=\small] at (1.5,1.8) {area stats};
  \node[font=\small] at (4.4,1.8) {time marks};
  \node[font=\small] at (1.5,1.0) {server[1]};
  \node[font=\small] at (4.4,1.0) {token, pri};
  \node[font=\small] at (1.5,0.4) {server[n]};
  \node[font=\small] at (4.4,0.4) {token, pri};

  \draw[line width=1pt] (7.2,0.3) rectangle (12.5,3.2);
  \draw[line width=0.8pt] (7.2,2.5) -- (12.5,2.5);
  \draw[line width=0.8pt] (7.2,1.8) -- (12.5,1.8);
  \draw[line width=0.8pt] (7.2,1.1) -- (12.5,1.1);
  \draw[line width=0.8pt] (9.7,0.3) -- (9.7,3.2);
  \node[font=\small] at (8.45,2.85) {event};
  \node[font=\small] at (11.1,2.85) {token};
  \node[font=\small] at (8.45,2.15) {priority};
  \node[font=\small] at (11.1,2.15) {time left};
  \node[font=\small] at (8.45,1.45) {next};
  \node[font=\small] at (11.1,1.45) {prev};
  \node[font=\small] at (9.85,0.75) {queue element};
  \draw[->,line width=0.9pt] (5.9,2.8) -- (7.1,2.8);
\end{tikzpicture}
\caption{\texttt{smpl} Facility Descriptor and Queue Structure}
\label{fig:smpl-facility-structure}
\end{figure}

\section{Event Scheduling}
\label{sec:smpl-impl-events}

The simulation program schedules events through:
\begin{itemize}
\item \texttt{schedule(ev,te,tkn)}: allocate element, set event/time/token, insert
  in event list.
\item \texttt{cause(\&ev,\&tkn)}: pop earliest event, advance clock, return event and
  token to model, recycle element.
\item \texttt{cancel(ev)}: search and remove event by number.
\item \texttt{suspend(tkn)}: remove scheduled event for token (used by preemption).
\end{itemize}

Event-list and queue insertion use \texttt{enlist()}, a generic sorted linked-list
insert routine:
\begin{itemize}
\item event list sorted by ascending occurrence time,
\item facility queues sorted by descending priority.
\end{itemize}

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=Latex]
  \foreach \x/\lab in {
    0.8/{head},
    3.2/{(t=12.1,e=3,tk=7)},
    7.2/{(t=12.8,e=1,tk=2)},
    11.2/{(t=13.5,e=4,tk=9)},
    15.2/{tail}
  } {
    \draw[line width=0.95pt] (\x,0) rectangle ++(2.7,1.1);
    \node[font=\small] at (\x+1.35,0.55) {\lab};
  }
  \draw[->,line width=0.9pt] (3.5,0.55) -- (7.1,0.55);
  \draw[->,line width=0.9pt] (7.5,0.55) -- (11.1,0.55);
  \draw[->,line width=0.9pt] (11.5,0.55) -- (15.1,0.55);
  \node[font=\small] at (9.0,-0.5) {event list sorted by ascending event time};
\end{tikzpicture}
\caption{\texttt{smpl} Event List Structure}
\label{fig:smpl-event-list}
\end{figure}

When present, \texttt{mtr} interaction is triggered primarily from
\texttt{cause()} at event boundaries.

\section{Facility Reservation and Release}
\label{sec:smpl-impl-reserve-release}

Non-preemptive requests use \texttt{request(f,tkn,pri)}:
\begin{itemize}
\item if a server is free, reserve immediately;
\item otherwise create queue entry (token, priority, current event, remaining time)
  and insert into priority queue.
\end{itemize}

Preemptive requests use \texttt{preempt(f,tkn,pri)}:
\begin{itemize}
\item if free server exists, reserve;
\item else compare against lowest-priority busy server;
\item if not higher priority, queue as blocked request;
\item if higher priority, suspend interrupted token's completion event, queue it as
  preempted work, account preemption statistics, and reserve server for requestor.
\end{itemize}

\texttt{release(f,tkn)} frees one server reserved by token \texttt{tkn}, updates
busy-period and release counters, and if queue is non-empty:
\begin{itemize}
\item dequeues highest-priority waiting entry,
\item either reschedules blocked request's event routine (remaining time $=0$),
\item or resumes preempted request with saved remaining time ($>0$).
\end{itemize}

The chapter notes one edge case: if preemption occurs exactly at planned
completion, a tiny nonzero residual is used to distinguish preempted work from
blocked work.

\section{Facility Query Functions}
\label{sec:smpl-impl-query}

Single-argument facility query calls provide instantaneous or average measures:
\begin{itemize}
\item \texttt{status()}, \texttt{inq()} (instantaneous busy/queue state),
\item \texttt{U()}, \texttt{B()}, \texttt{Lq()} (utilization, mean busy period, mean queue length).
\end{itemize}

These functions are used in built-in reporting and in model-specific output.

\section{Debugging and Reporting Functions}
\label{sec:smpl-impl-debug-report}

\texttt{smpl} routes output through the current file pointer (\texttt{opf}) and
tracks page/screen line counts. The model may change destination via
\texttt{sendto()}.

Trace control:
\begin{itemize}
\item \texttt{trace(0)} off,
\item \texttt{trace(1..3)} on (with different pause/page behavior),
\item \texttt{trace(4)} account program-generated trace line.
\end{itemize}

\texttt{msg()} formats trace records (time stamp, token, phrase, qualifier), while
\texttt{end\_line()}, \texttt{newpage()}, and \texttt{endpage()} manage pagination or
screen pausing.

\begin{figure}[ht]
\centering
\begin{tabular}{lll}
\toprule
Trace field & Meaning & Example \\
\midrule
time & current simulation clock & 15200.217 \\
token & active entity identifier & 17 \\
event phrase & action mnemonic & ARRIVE / REQUEST / RELEASE \\
qualifier & facility/event identifier & cpu\#2 / e=4 \\
queue state & optional occupancy info & qlen=3 \\
note & optional model text & warmup complete \\
\bottomrule
\end{tabular}
\caption{Trace Message Parameters and Phrases}
\label{fig:smpl-trace-messages}
\end{figure}

\texttt{error()} prints diagnostics, optionally emits report output, and terminates.
\texttt{report()} delegates to facility report generation (\texttt{reportf()},
\texttt{rept\_page()}).

\section{Random Variate Generation}
\label{sec:smpl-impl-rand}

Random support lives in \texttt{rand.c}:
\texttt{ranf}, \texttt{stream}, \texttt{seed}, \texttt{random}, \texttt{expntl},
\texttt{erlang}, \texttt{hyperx}, and \texttt{normal}.

\begin{figure}[ht]
\centering
\begin{tabular}{ll}
\toprule
Group & \texttt{rand.c} functions \\
\midrule
Core RNG & \texttt{ranf}, \texttt{random}, \texttt{stream}, \texttt{seed} \\
Exponential family & \texttt{expntl}, \texttt{erlang}, \texttt{hyperx} \\
Normal family & \texttt{normal} (Marsaglia-Bray polar method) \\
Support & stream seed table \texttt{In[]}, helper constants \\
\bottomrule
\end{tabular}
\caption{\texttt{rand.c} Functions}
\label{fig:smpl-rand-functions}
\end{figure}

The base generator is multiplicative congruential:
\begin{equation}
I_{n+1} = a I_n \bmod M
\label{eq:smpl-rng-main}
\end{equation}
with $a=16807$ and $M=2^{31}-1$.

To avoid slow/awkward direct modulo arithmetic, the implementation computes:
\begin{equation}
Z = 16807I_n \bmod 2^{31}
\label{eq:smpl-rng-z}
\end{equation}
\begin{equation}
K = \left\lfloor \frac{16807I_n}{2^{31}} \right\rfloor
\label{eq:smpl-rng-k}
\end{equation}
then combines them as:
\begin{equation}
I_{n+1} =
\begin{cases}
Z + K, & Z+K < M \\
Z + K - M, & Z+K \ge M
\end{cases}
\label{eq:smpl-rng-combine}
\end{equation}

On 32-bit-long / 16-bit-short targets, a simulated double-precision multiply
forms the 46-bit product.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[>=Latex]
  \draw[line width=0.95pt] (0,1.8) rectangle (2.5,2.8);
  \draw[line width=0.95pt] (2.5,1.8) rectangle (5.0,2.8);
  \node at (1.25,2.3) {$a_h$};
  \node at (3.75,2.3) {$a_l$};

  \draw[line width=0.95pt] (0,0.2) rectangle (2.5,1.2);
  \draw[line width=0.95pt] (2.5,0.2) rectangle (5.0,1.2);
  \node at (1.25,0.7) {$b_h$};
  \node at (3.75,0.7) {$b_l$};

  \draw[->,line width=0.9pt] (5.2,2.3) -- (7.2,2.3) node[midway,above,font=\small] {$a_h b_h$};
  \draw[->,line width=0.9pt] (5.2,1.9) -- (7.2,1.3) node[midway,right,font=\small] {$a_h b_l$};
  \draw[->,line width=0.9pt] (5.2,1.1) -- (7.2,1.7) node[midway,right,font=\small] {$a_l b_h$};
  \draw[->,line width=0.9pt] (5.2,0.7) -- (7.2,0.7) node[midway,below,font=\small] {$a_l b_l$};

  \draw[line width=0.95pt] (7.4,0.2) rectangle (11.8,2.8);
  \node[font=\small] at (9.6,2.45) {carry combine};
  \node[font=\small] at (9.6,1.75) {high word};
  \node[font=\small] at (9.6,1.05) {low word};
  \node[font=\small] at (9.6,0.4) {mod $2^{31}$ adjustment};
\end{tikzpicture}
\caption{Simulated Double Precision Multiply Operands and Operations}
\label{fig:smpl-sim-mul}
\end{figure}

Stream handling supports 15 seeds by default (\texttt{In[]} table), each stream
offset in sequence space. \texttt{seed()} allows state save/restore.

Distribution generators:
\begin{itemize}
\item \texttt{expntl(x)} for negative exponential mean $x$,
\item \texttt{erlang(x,s)} via product/sum transform for stage count
  $k \approx (x/s)^2$,
\item \texttt{hyperx(x,s)} for a two-stage hyperexponential family,
\item \texttt{normal(x,s)} using the Marsaglia-Bray polar method.
\end{itemize}

For Erlang generation:
\begin{equation}
V = -\frac{x}{k}\ln\left(\prod_{i=1}^{k} r_i\right)
\label{eq:smpl-erlang}
\end{equation}
where $r_i$ are i.i.d.\ uniform variates from \texttt{ranf()}.

\section{The \texttt{smpl.h} File}
\label{sec:smpl-impl-header}

\texttt{smpl.h} is intended for inclusion by all simulation programs. It provides:
\begin{itemize}
\item required includes (\texttt{stdio.h}, \texttt{math.h}),
\item \texttt{typedef}/\texttt{\#define} conventions used by \texttt{smpl},
\item extern declarations for non-\texttt{int}-returning subsystem functions.
\end{itemize}

As new subsystem functions are added, corresponding declarations should be
kept in sync.

\section{Summary}
\label{sec:smpl-impl-summary}

The chapter's implementation-level message is:
\begin{enumerate}
\item start from a known-good baseline (\texttt{smpl.c}/\texttt{rand.c}),
\item change as little as possible initially (usually only \texttt{ranf()} porting),
\item validate with simple analytically-checkable models,
\item then extend/restructure with confidence.
\end{enumerate}

If results differ from the book's exact sample runs, determine whether the
difference is functional or statistical (especially when substituting a different
RNG). Trace analysis on small test models is the recommended first debug tool.
